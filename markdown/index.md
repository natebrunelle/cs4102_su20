---
title: cs4102
...

<div style="display:table; font-size:200%; margin: 1em auto; padding:1ex; box-shadow: 0 1px 10px rgba(0,0,0,.1); border: thin solid #eee; border-radius:1ex; background-image: linear-gradient(to bottom, #ffffff, #f2f2f2);">[Join Lecture (Weekdays at 10:30am)](https://virginia.zoom.us/j/134834401)</div>

# Course Overview 

The goal of this course is to build a tool kit to better solve a variety of computational problems, and to evaluate the quality of such solutions. In particular, we will cover:

- Formal metrics for evaluating algorithm complexity (including the asymptotic classes big-oh, big-omega, big-theta, little-oh, and little-omega)
- Evaluating an algorithm's usage of resources (including time and space complexities) by a worst-case analysis, expected-case analysis, and amortized analysis
- Algorithm design strategies (including divide and conquer, dynamic programming, greedy, and reductions)
- The impact of data-structure choice on algorithm design
- Proving algorithm correctness
- Proving worst-case lower bounds on algorithm efficiency
- Algorithms on graphs
- NP-Completeness

## Learning Outcomes

At the conclusion of this course, a successful student will be able to:

- Analyze a pre-written algorithm to determine its resource complexity
- Employ the strategies of divide and conquer, greedy, and dynamic programming (perhaps in concert) to develop novel algorithms
- Prove the correctness of algorithms built using these strategies
- Identify trade-offs in algorithm design (such as time vs. space, average-case vs. worst case, dynamic vs. static)
- Prove lower bounds on algorithm complexity



## Eligibility

You should take this course if and only if

1. You have credit for  CS 2150 (or an equivalent data structures course)
1. You have credit for CS 2102 (or an equivalent discrete math course)


### Background

This course will assume knowledge of several topics from discrete math (CS2102 at UVA), two semesters of programming experience (through CS2110 at UVA), and data structures (CS2150 at UVA)

In particular, we assume knowledge of (with recommended resources for review):

- Logarithms and identities ([Log rules](https://en.wikipedia.org/wiki/List_of_logarithmic_identities))
- Sets ([CS2102 Sets Primer](http://www.cs.virginia.edu/luther/DMT1/S2020/sets.html))
- Functions ([Section 4.3 of this text](http://www.cs.virginia.edu/luther/DMT1/S2020/files/mcs.pdf))
- Proof Techniques ([CS2102 Proof Techniques](http://www.cs.virginia.edu/luther/DMT1/S2020/techniques-q8.html))
- Proof Styles, we'll mostly be using "prose proofs" ([CS2102 Proof style guide](http://www.cs.virginia.edu/luther/DMT1/S2020/proofs.html))
- Logic and Notation ([CS2102 Glossary of logical terms](http://www.cs.virginia.edu/luther/DMT1/S2020/glossary.html))
- Recursion ([CS2110 part 1](https://deternitydx.github.io/uvacs4102/pdfs/31-recursion.pdf), [CS2110 part 2](https://deternitydx.github.io/uvacs4102/pdfs/32-recursion.pdf))
- Trees ([CS2150 trees](https://aaronbloomfield.github.io/pdr/slides/05-trees.html#/))
- Queues ([CS2150 lists](https://aaronbloomfield.github.io/pdr/slides/02-lists.html#/))
- Stacks ([CS2150 lists](https://aaronbloomfield.github.io/pdr/slides/02-lists.html#/))
- Priority Queues ([CS2150 Heaps](https://aaronbloomfield.github.io/pdr/slides/10-heaps-huffman.html#/cover))
- Hash Tables ([CS2150 Hashing](https://aaronbloomfield.github.io/pdr/slides/06-hashes.html#/cover))
- Graphs ([CS2150 Graphs](https://aaronbloomfield.github.io/pdr/slides/11-graphs.html#/cover))

For each of the CS2102 topics, you can view last [semester's lectures](http://www.cs.virginia.edu/luther/DMT1/S2020/schedule.html) for more information








